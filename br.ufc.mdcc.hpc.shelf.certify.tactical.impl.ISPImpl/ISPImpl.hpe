<?xml version="1.0" encoding="ASCII"?>
<component:component xmlns:component="http://www.example.org/HashComponent">
  <header hash_component_UID="002400000480000094000000060200000024000052534131000400001100000061d199c695add57ea4802b7e35d845bab68e87155e490eb4f79ef404ae53430d8de08f9c454832d95b8ddcd10a6a26a3200c2b787cc0e73be9257fcfc5607c5459e8812bd5ad344d25c3cffd7ef7d38c66e344dab1230f3516a31e0fe346cfac875fd3932177425cb2cf6bf2b760ed0db99e217ce62520430e45e077ee6a3897" isAbstract="false" kind="Computation" name="ISPImpl" packagePath="br.ufc.mdcc.hpc.shelf.certify.tactical.impl">
    <baseType>
      <extensionType>
        <implements>true</implements>
      </extensionType>
      <component hash_component_UID="00240000048000009400000006020000002400005253413100040000110000004915c83120755567a2ee4a1ea5e706412b0d204ee81d21512214b8c577bcef1d3754c811ce0f0783b0e827dbc889bcf77476fbfe577cfd565deaa92d7883207fdc9358f9e2b38eb0ff0719bdc5bf307cdbdf9ca05976167598d3c3168693cc1b1a21b44ecad3cbf151dd19b45826de329f7c719c3a040c6687c92d8db1b1f88b" localRef="base" location="br.ufc.mdcc.hpc.shelf.certify.tactical.ISP/ISP.hpe" name="ISP" package="br.ufc.mdcc.hpc.shelf.certify.tactical" version="1.0.0.0">
        <visualDescription h="60" w="100" x="176" y="240">
          <color b="255" g="255" r="255"/>
        </visualDescription>
        <parameter formFieldId="verify_data_port_server_type" varName="S"/>
        <parameter formFieldId="verify_data_port_client_type" varName="C"/>
        <port index_replica="0" localRef="verify" location="br.ufc.mdcc.hpc.storm.binding.task.TaskBindingBase/TaskBindingBase.hpe" multiple="false" name="TaskBindingBase" package="br.ufc.mdcc.hpc.storm.binding.task" exposed="true">
          <visualDescription h="60" w="146" x="410" y="67">
            <color b="255" g="255" r="255"/>
          </visualDescription>
          <parameter formFieldId="task_port_type" varName="T"/>
          <unitBounds facet="0" facet_instance="0" facet_instance_enclosing="0" parallel="true" uRef="peer">
            <visualDescription h="20" w="20" x="14" y="19"/>
          </unitBounds>
        </port>
        <port index_replica="0" localRef="verify_data" location="br.ufc.mdcc.hpc.shelf.tactical.environment.VerifyDataPort/VerifyDataPort.hpe" multiple="false" name="VerifyDataPort" package="br.ufc.mdcc.hpc.shelf.tactical.environment" exposed="true">
          <visualDescription h="63" w="218" x="345" y="341">
            <color b="255" g="255" r="255"/>
          </visualDescription>
          <parameter formFieldId="client_port_type" varName="C"/>
          <parameter formFieldId="server_port_type" varName="S"/>
          <unitBounds facet="0" facet_instance="0" parallel="false" uRef="client">
            <visualDescription h="20" w="20" x="5" y="2"/>
          </unitBounds>
          <unitBounds facet="1" facet_instance="0" facet_instance_enclosing="0" parallel="false" uRef="server">
            <visualDescription h="20" w="20" x="28" y="2"/>
          </unitBounds>
        </port>
        <unitBounds facet="0" facet_instance="0" facet_instance_enclosing="0" parallel="true" uRef="tactical">
          <visualDescription h="20" w="20" x="5" y="2"/>
        </unitBounds>
      </component>
    </baseType>
    <versions field1="1" field2="0" field3="0" field4="0"/>
    <visualAttributes>
      <color b="255" g="255" r="255"/>
    </visualAttributes>
    <facet_configuration facet="0" multiple="false"/>
  </header>
  <componentInfo>
    <innerComponent localRef="verify_client_port_type" location="br.ufc.mdcc.hpc.shelf.tactical.environment.VerifyDataPortClientTypeC4/VerifyDataPortClientTypeC4.hpe" multiple="false" name="VerifyDataPortClientTypeC4" package="br.ufc.mdcc.hpc.shelf.tactical.environment" exposed="false">
      <visualDescription h="60" w="100" x="83" y="342">
        <color b="255" g="255" r="255"/>
      </visualDescription>
      <unitBounds facet="0" facet_instance="0" parallel="true" uRef="environment_port_type">
        <visualDescription h="20" w="20" x="5" y="2"/>
      </unitBounds>
    </innerComponent>
    <innerComponent localRef="verify_server_port_type" location="br.ufc.mdcc.hpc.shelf.tactical.environment.VerifyDataPortServerTypeC4/VerifyDataPortServerTypeC4.hpe" multiple="false" name="VerifyDataPortServerTypeC4" package="br.ufc.mdcc.hpc.shelf.tactical.environment" exposed="false">
      <visualDescription h="60" w="100" x="31" y="428">
        <color b="255" g="255" r="255"/>
      </visualDescription>
      <unitBounds facet="0" facet_instance="0" parallel="true" uRef="environment_port_type">
        <visualDescription h="20" w="20" x="5" y="2"/>
      </unitBounds>
    </innerComponent>
    <supplyParameter cRef="verify_client_port_type" direct="true" varName="C"/>
    <supplyParameter cRef="verify_server_port_type" direct="true" varName="S"/>
    <interface iRef="IISPImpl" nArgs="1">
      <sources sourceType="C# Language" versionId="1.0.0.0">
        <file contents="/* Automatically Generated Code */&#xA;&#xA;using System;&#xA;using br.ufc.pargo.hpe.backend.DGAC;&#xA;using br.ufc.pargo.hpe.basic;&#xA;using br.ufc.pargo.hpe.kinds;&#xA;using br.ufc.mdcc.hpc.shelf.tactical.environment.VerifyDataPort;&#xA;using br.ufc.mdcc.hpc.shelf.tactical.environment.VerifyDataPortServerType;&#xA;using br.ufc.mdcc.hpc.storm.binding.task.TaskBindingBase;&#xA;using br.ufc.mdcc.hpc.shelf.tactical.task.VerifyPortType;&#xA;using br.ufc.mdcc.hpc.shelf.certify.tactical.ISP;&#xA;using br.ufc.mdcc.hpc.shelf.tactical.environment.VerifyDataPortServerTypeC4;&#xA;&#xA;namespace br.ufc.mdcc.hpc.shelf.certify.tactical.impl.ISPImpl &#xA;{&#xA;&#x9;public abstract class BaseIISPImpl&lt;S>: Computation, BaseIISP&lt;S>&#xA;&#x9;where S:IVerifyDataPortServerTypeC4&#xA;&#x9;{&#xA;&#x9;&#x9;private IVerifyServerPort&lt;S> verify_data = null;&#xA;&#xA;&#x9;&#x9;public IVerifyServerPort&lt;S> Verify_data&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;if (this.verify_data == null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this.verify_data = (IVerifyServerPort&lt;S>) Services.getPort(&quot;verify_data&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;return this.verify_data;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;private ITaskPort&lt;IVerifyPortType> verify = null;&#xA;&#xA;&#x9;&#x9;public ITaskPort&lt;IVerifyPortType> Verify&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;if (this.verify == null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this.verify = (ITaskPort&lt;IVerifyPortType>) Services.getPort(&quot;verify&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;return this.verify;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}" name="BaseIISPImpl.cs" srcType="base" uri="br.ufc.mdcc.hpc.shelf.certify.tactical.impl.ISPImpl/bin/1.0.0.0/BaseIISPImpl.dll" versionId="1.0.0.0">
          <dependency>br.ufc.mdcc.hpc.shelf.tactical.environment.VerifyDataPort/bin/1.0.0.0/IVerifyServerPort.dll</dependency>
          <dependency>br.ufc.mdcc.hpc.shelf.tactical.environment.VerifyDataPortServerType/bin/1.0.0.0/IVerifyDataPortServerType.dll</dependency>
          <dependency>br.ufc.mdcc.hpc.storm.binding.task.TaskBindingBase/bin/1.0.0.0/ITaskPort.dll</dependency>
          <dependency>br.ufc.mdcc.hpc.shelf.tactical.task.VerifyPortType/bin/1.0.0.0/IVerifyPortType.dll</dependency>
          <dependency>br.ufc.mdcc.hpc.shelf.certify.tactical.ISP/bin/1.0.0.0/BaseIISP.dll</dependency>
          <externalDependency>MPI</externalDependency>
        </file>
        <file contents="using System;&#xA;using br.ufc.pargo.hpe.backend.DGAC;&#xA;using br.ufc.pargo.hpe.basic;&#xA;using br.ufc.pargo.hpe.kinds;&#xA;using br.ufc.mdcc.hpc.shelf.certify.tactical.ISP;&#xA;using System.Diagnostics;&#xA;using br.ufc.mdcc.hpc.shelf.tactical.environment.impl.VerifyDataPortC4Impl;&#xA;using  br.ufc.mdcc.hpc.shelf.tactical.task.VerifyPortType;&#xA;using System.Threading;&#xA;&#xA;using MPI;&#xA;using br.ufc.mdcc.hpc.shelf.tactical.environment.VerifyDataPortServerTypeC4;&#xA;&#xA;&#xA;namespace br.ufc.mdcc.hpc.shelf.certify.tactical.impl.ISPImpl&#xA;{&#xA;&#x9;public class IISPImpl&lt;S> : BaseIISPImpl&lt;S>, IISP&lt;S>&#xA;&#x9;&#x9;where S:IVerifyDataPortServerTypeC4&#xA;&#x9;{&#xA;&#x9;&#x9;public string []programs; &#xA;&#x9;&#x9;public int num_programs; &#xA;&#x9;&#x9;public string[] args_programs;&#xA;&#x9;&#x9;public int []num_units_program;&#xA;&#x9;&#x9;public int num_threads = 1;&#xA;&#x9;&#x9;public int number_thread=0; &#xA;&#x9;&#x9;public int number_progs_consumed=0;&#xA;&#x9;&#x9;public bool verification_is_inconclusive = false;&#xA;&#x9;&#x9;public int number_programs_consumed=0;&#xA;&#x9;&#x9;public int [] num_programs_thread;&#xA;&#x9;&#x9;public string [][] programs_properties_status;&#xA;&#x9;&#x9;public string path;&#xA;&#x9;&#x9;public string []property_names;&#xA;&#x9;&#x9;public Boolean status_verification_properties;&#xA;&#x9;&#x9;public override void main()&#xA;&#x9;&#x9;{&#xA;&#xA;&#x9;&#x9;&#x9;while(true){&#xA;&#x9;&#x9;&#x9;&#x9;Verify.invoke (IVerify.VERIFY_PERFORM);&#xA;&#x9;&#x9;&#x9;&#x9;invoke_verify_perform ();&#xA;&#x9;&#x9;&#x9;&#x9;if (!verification_is_inconclusive) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;status_verification_properties = this.Communicator.Allreduce(false, Operation&lt;Boolean>.LogicalAnd);&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;status_verification_properties = this.Communicator.Allreduce(true, Operation&lt;Boolean>.LogicalAnd);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if&#x9;(status_verification_properties) Verify.invoke (IVerify.VERIFY_CONCLUSIVE);&#xA;&#x9;&#x9;&#x9;&#x9;else Verify.invoke (IVerify.VERIFY_INCONCLUSIVE);&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void invoke_verify_perform(){&#xA;&#xA;&#x9;&#x9;&#x9;//&#x9;Communicator.world.Receive&lt;int>(certifier,verify_perform);&#xA;&#x9;&#x9;&#x9;verify_ ();&#xA;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;void setNumProgs(int number){&#xA;&#x9;&#x9;&#x9;path =System.Environment.GetEnvironmentVariable(&quot;PATH_TAC_ISP_EXEC&quot;);&#xA;&#x9;&#x9;&#x9;Console.WriteLine(&quot;path &quot; + path); &#xA;&#x9;&#x9;&#x9;property_names = new string[4];&#xA;&#x9;&#x9;&#x9;property_names [0] = &quot;deadlock absence&quot;;&#xA;&#x9;&#x9;&#x9;property_names [1] = &quot;no_irrelevant_barriers&quot;;&#xA;&#x9;&#x9;&#x9;property_names [2] = &quot;no_object_leaks&quot;;&#xA;&#x9;&#x9;&#x9;property_names [3] = &quot;no_comm_races&quot;;&#xA;&#xA;&#x9;&#x9;&#x9;num_programs = number;&#xA;&#xA;&#xA;&#x9;&#x9;&#x9;//&#x9;my_certifier_tag= Communicator.world.Receive&lt;int>(certifier,dataCertifierTactical);&#xA;&#xA;&#x9;&#x9;&#x9;Console.WriteLine (&quot;rank tactical &quot;+ this.Rank + &#xA;&#x9;&#x9;&#x9;&#x9;&quot; num progs:&quot; + num_programs);&#xA;&#x9;&#x9;&#x9;programs = new string[num_programs];&#xA;&#x9;&#x9;&#x9;args_programs = new string[num_programs];&#xA;&#xA;&#x9;&#x9;&#x9;num_units_program=new int[num_programs+1];&#xA;&#x9;&#x9;&#x9;programs_properties_status = new string[num_programs][];&#xA;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;void setUnitsProgs(ref int [] num_units_program){&#xA;&#x9;&#x9;&#x9;this.num_units_program = num_units_program;&#xA;&#xA;&#x9;&#x9;&#x9;//Communicator.world.Receive&lt;int>(certifier,dataCertifierTactical, ref num_units_program);&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;void setArgsProgs(ref string [] args_programs){&#xA;&#x9;&#x9;&#x9;this.args_programs = args_programs;&#xA;&#xA;&#x9;&#x9;&#x9;//Communicator.world.Receive&lt;string>(certifier,dataCertifierTactical, ref args_programs);&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;void setProgs(ref string [] programs){&#xA;&#x9;&#x9;&#x9;this.programs = programs;&#xA;&#xA;&#x9;&#x9;&#x9;//Communicator.world.Receive&lt;string>(certifier,dataCertifierTactical, ref programs);&#xA;&#x9;&#x9;&#x9;Console.WriteLine (&quot;recebi tudo :&quot; + this.Rank);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void verify_(){&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;&#x9;if (num_threads > 1) {&#xA;&#x9;&#x9;&#x9;&#x9;num_programs_thread = new int[num_threads];&#xA;&#x9;&#x9;&#x9;&#x9;Thread[] threadv = new Thread[num_threads];&#xA;&#x9;&#x9;&#x9;&#x9;int offset = (int)Math.Ceiling ((double)num_programs / num_threads);&#xA;&#x9;&#x9;&#x9;&#x9;Console.WriteLine (&quot;Rank ThreadOffset number_properties_unit &quot; + this.Rank + &quot; &quot; + offset + &quot; &quot; + num_programs);&#xA;&#x9;&#x9;&#x9;&#x9;int num_programs_aux = num_programs;&#xA;&#x9;&#x9;&#x9;&#x9;for (int i = 0; i &lt; num_threads; i++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (num_programs_aux > offset) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;num_programs_thread [i] = offset;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;num_programs_aux -= offset;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;num_programs_thread [i] = num_programs_aux;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;num_programs_aux = 0;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;threadv [i] = new Thread ((ThreadStart)delegate() {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;int my_number_thread;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;int prog;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;lock (this) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;my_number_thread = number_thread;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;number_thread++;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;prog = number_progs_consumed;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;number_progs_consumed += num_programs_thread [my_number_thread];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine (&quot;TACTICAL ISP - CREATING THREAD: &quot; + my_number_thread + &quot; from &quot; + this.Rank + &quot; num programs &quot; + num_programs + &quot; num programs thread &quot; + num_programs_thread [my_number_thread]);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;for (int j = 0; j &lt; num_programs_thread [my_number_thread]; j++) {&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine (&quot;Thread &quot; + my_number_thread + &quot; from &quot; + &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;this.Rank + &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&quot; dealing with program &quot; + programs[prog + j] );&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;TacticalAdapterISP t = new TacticalAdapterISP (path, programs[prog + j], &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;num_units_program[prog + j], args_programs[prog + j], 9900+2*this.Rank + my_number_thread);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;int result = t.run ();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine (&quot;Thread&quot; + my_number_thread + &quot; de &quot; + this.Rank + &quot;:Result of verification of program &quot; +programs[prog + j]+ &quot;: &quot; + result + &quot; storing status for &quot; + (prog + j));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (result == -1){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;verification_is_inconclusive = true;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;programs_properties_status[prog + j]=t.get_property_results();&#xA;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;});&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;threadv [i].Start ();&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;for (int i = 0; i &lt; num_threads; i++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine (&quot;TACTICAL ISP - waiting threads : &quot; + i + &quot;from &quot; + this.Rank);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;threadv [i].Join ();&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;for (int j = 0; j &lt; num_programs; j++) {&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine ( this.Rank + &quot; dealing with program &quot; + programs[j]);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;TacticalAdapterISP t = new TacticalAdapterISP (path, programs[j], num_units_program[j], args_programs[j], 9800+2*this.Rank+j);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;int result = t.run ();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine ( this.Rank + &quot;:Result of verification of program &quot; +programs[j]+ &quot;: &quot; + result + &quot; storing status for &quot; + j);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (result == -1)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;verification_is_inconclusive = true;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;programs_properties_status[j]=t.get_property_results();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#xA;&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;class TacticalAdapterISP&#xA;&#xA;&#x9;{  &#xA;&#x9;&#x9;string mpi_file; int number_units_mpi_file; //int result;&#xA;&#x9;&#x9;string path;&#xA;&#x9;&#x9;string params_mpi_file;&#xA;&#x9;&#x9;int port;&#xA;&#x9;&#x9;bool is_inconclusive = false;&#xA;&#x9;&#x9;string []property_results;&#xA;&#xA;&#x9;&#x9;public static void _Main(){&#xA;&#x9;&#x9;&#x9;Console.WriteLine (&quot;Teste Adaptador T&#xe1;tico ISP&quot;);&#xA;&#xA;&#x9;&#x9;&#x9;TacticalAdapterISP t = new TacticalAdapterISP &#xA;&#x9;&#x9;&#x9;&#x9;(&quot;/home/allberson/Dropbox/HPC-Shelf-MapReduce/br.ufc.mdcc.hpcshelf.certifier.impl.computation.TacticalISPImpl/br.ufc.mdcc.hpcshelf.certifier.impl.computation.TacticalISPImpl/bin/Debug&quot;, &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&quot;mProjExecMPI&quot;, 4, &quot;\&quot;-$ /home/allberson/Dropbox/m101/rawdir /home/allberson/Dropbox/m101/images-rawdir.tbl /home/allberson/Dropbox/m101/template.hdr /home/allberson/Dropbox/m101/projdir /home/allberson/Dropbox/m101/stats.tbl\&quot;&quot;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;,9000);&#xA;&#x9;&#x9;&#x9;int result = t.run ();&#xA;&#xA;&#x9;&#x9;&#x9;Console.WriteLine (&quot;Resultado da verifica&#xe7;&#xe3;o das propriedades: &quot; + result);&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;public TacticalAdapterISP (string path, string mpi_file, int number_units_mpi_file, string params_mpi_file, int port)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.path = path;&#xA;&#x9;&#x9;&#x9;this.mpi_file = mpi_file;&#xA;&#x9;&#x9;&#x9;this.number_units_mpi_file = number_units_mpi_file;&#xA;&#x9;&#x9;&#x9;this.params_mpi_file = params_mpi_file;&#xA;&#x9;&#x9;&#x9;this.port = port;&#xA;&#x9;&#x9;&#x9;property_results = new string[4];&#xA;&#x9;&#x9;&#x9;/*property_results[0]  =false;//deadlock_absence&#xA;&#x9;&#x9;&#x9;property_results[1]= true; //no_object_leak &#xA;&#x9;&#x9;&#x9;property_results[2] = true; //no_comm_races &#xA;&#x9;&#x9;&#x9;property_results[3]  = false;//no_irrelevant_barriers*/&#xA;&#x9;&#x9;&#x9;property_results [2] = &quot;no MPI object leaks&quot;;&#xA;&#x9;&#x9;&#x9;property_results [3] = &quot;no communication races&quot;; &#xA;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;public string[] get_property_results(){&#xA;&#x9;&#x9;&#x9;return property_results;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;public int run(){&#xA;&#xA;&#x9;&#x9;&#x9;Process proc = new System.Diagnostics.Process ();&#xA;&#x9;&#x9;&#x9;proc.StartInfo.FileName = &quot;/bin/bash&quot;;&#xA;&#x9;&#x9;&#x9;//proc.StartInfo.WorkingDirectory = &quot;/home/00292431309/Dropbox/HPC-Shelf-MapReduce-master/br.ufc.mdcc.hpcshelf.mapreduce.impl.computation.ReducerImpl/src/1.0.0.0&quot;;&#xA;&#xA;&#x9;&#x9;&#x9;proc.StartInfo.Arguments = path+&quot;/run.sh &quot; +number_units_mpi_file + &quot; &quot;+ mpi_file + &quot; &quot; + &#xA;&#x9;&#x9;&#x9;&#x9;params_mpi_file + &quot; &quot; +port;&#xA;&#x9;&#x9;&#x9;//Console.WriteLine (&quot;Arguments &quot; + proc.StartInfo.Arguments);&#xA;&#x9;&#x9;&#x9;proc.StartInfo.UseShellExecute = false; &#xA;&#x9;&#x9;&#x9;proc.StartInfo.RedirectStandardOutput = true;&#xA;&#x9;&#x9;&#x9;proc.StartInfo.RedirectStandardError = true;&#xA;&#x9;&#x9;&#x9;proc.Start ();&#xA;&#x9;&#x9;&#x9;string output;&#xA;&#xA;&#x9;&#x9;&#x9;while (!proc.StandardError.EndOfStream) {&#xA;&#x9;&#x9;&#x9;&#x9;if(!is_inconclusive) is_inconclusive = true;&#xA;&#x9;&#x9;&#x9;&#x9;output = proc.StandardError.ReadLine ();&#xA;&#x9;&#x9;&#x9;&#x9;Console.WriteLine (&quot;Log de Erro - Adaptador T&#xe1;tico ISP&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;//Console.WriteLine (&quot;Arguments &quot; + proc.StartInfo.Arguments);&#xA;&#x9;&#x9;&#x9;&#x9;Console.WriteLine (output);&#xA;&#x9;&#x9;&#x9;&#x9;//result Convert.ToBoolean(result);&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;//Console.WriteLine (&quot;Sa&#xed;da padr&#xe3;o - Adaptador T&#xe1;tico ISP&quot;);&#xA;&#x9;&#x9;&#x9;while (!proc.StandardOutput.EndOfStream) {&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;output = proc.StandardOutput.ReadLine ();&#xA;&#x9;&#x9;&#x9;&#x9;//&#x9;Console.WriteLine (output);&#xA;&#x9;&#x9;&#x9;&#x9;if (output == &quot;ISP detected no deadlocks!&quot;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;//&#x9;Console.WriteLine (output);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;property_results[0] = &quot;deadlock absence&quot;;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (output == &quot;There were no Irrelevant Barriers!&quot;) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;//Console.WriteLine (output);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;property_results[1] = &quot;no irrelevant barriers&quot;;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (output.Contains(&quot;Resource leaks detected&quot;)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;//Console.WriteLine (output);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;property_results[2] = &quot; &quot;;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if (output.Contains(&quot;communication race&quot;)){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;//Console.WriteLine (output);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;property_results[3] = &quot; &quot;;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;//Console.WriteLine (deadlock_absence.ToString() + no_irrelevant_barriers.ToString() + no_object_leak.ToString() + no_comm_races.ToString());&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;//result Convert.ToBoolean(result);&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;/*if (deadlock_absence &amp;&amp; no_irrelevant_barriers &amp;&amp; no_object_leak &amp;&amp; no_comm_races) {&#xA;&#x9;&#x9;&#x9;&#x9;return 0;&#xA;&#x9;&#x9;&#x9;}*/&#xA;&#x9;&#x9;&#x9;if (is_inconclusive) {&#xA;&#x9;&#x9;&#x9;&#x9;return -1;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;return 0;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;" name="IISPImpl.cs" srcType="user" uri="br.ufc.mdcc.hpc.shelf.certify.tactical.impl.ISPImpl/bin/1.0.0.0/IISPImpl.dll" versionId="1.0.0.0">
          <dependency>%WORKSPACE/br.ufc.mdcc.hpc.shelf.certify.tactical.impl.ISPImpl/bin/1.0.0.0/BaseIISPImpl.dll</dependency>
          <dependency>br.ufc.mdcc.hpc.shelf.certify.tactical.ISP/bin/1.0.0.0/IISP.dll</dependency>
          <externalDependency>MPI</externalDependency>
        </file>
      </sources>
      <visualDescription h="40" w="80" x="144" y="50">
        <color b="0" g="255" r="255"/>
      </visualDescription>
      <externalReferences>MPI</externalReferences>
      <parameter iname="IVerifyDataPortServerTypeC4" order="0" parid="verify_data_port_server_type" uname="environment_port_type" varid="S"/>
      <action id="main">
        <protocol/>
      </action>
    </interface>
    <unit facet="0" iRef="IISPImpl" multiple="true" private="false" replica="0" uRef="tactical" visibleInterface="true">
      <super cRef="base" uRef="tactical"/>
      <visualDescription h="40" w="80" x="86" y="135"/>
    </unit>
  </componentInfo>
</component:component>